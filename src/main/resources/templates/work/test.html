<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>현대자동차 울산공장 의장공정 4단계 업무 프로세스 시스템</title>
    <style>
        body {
            font-family: 'Noto Sans KR', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .boxs {
            display: block;
            padding: 20px;
            position: relative;
            min-height: 200vh;
            width: 100%;
            box-sizing: border-box;
        }

        .box {
            min-width: 300px;
            max-width: 300px;
            min-height: 200px;
            width: auto;
            height: auto;
            border: 2px solid #2c3e50;
            border-radius: 8px;
            background: #ffffff;
            position: absolute;
            user-select: none;
            cursor: move;
            overflow: visible;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.3s ease, transform 0.1s ease;
        }

        .box:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .box.dragging {
            transform: scale(1.02);
            opacity: 0.9;
            z-index: 1000;
        }

        .box h4 {
            margin-top: 0;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            color: #205295;
            font-size: 1.1em;
        }

        .box ul,
        .box ol {
            margin: 0;
            padding-left: 20px;
            line-height: 1.5;
        }

        .box p {
            margin: 10px 0;
            line-height: 1.5;
        }

        /* 프로세스 그룹별 색상 구분 */
        .receiving {
            border-color: #3498db;
            border-width: 3px;
        }

        .receiving h4 {
            color: #2980b9;
            font-weight: bold;
        }

        .sequencing {
            border-color: #e67e22;
            border-width: 3px;
        }

        .sequencing h4 {
            color: #d35400;
            font-weight: bold;
        }

        .viewing {
            border-color: #2ecc71;
            border-width: 3px;
        }

        .viewing h4 {
            color: #27ae60;
            font-weight: bold;
        }

        .printing {
            border-color: #9b59b6;
            border-width: 3px;
        }

        .printing h4 {
            color: #8e44ad;
            font-weight: bold;
        }

        .phase-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin: 20px 0;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            position: relative;
        }

        .phase-1 {
            color: #2980b9;
            border-left: 5px solid #3498db;
        }

        .phase-2 {
            color: #d35400;
            border-left: 5px solid #e67e22;
        }

        .phase-3 {
            color: #27ae60;
            border-left: 5px solid #2ecc71;
        }

        .phase-4 {
            color: #8e44ad;
            border-left: 5px solid #9b59b6;
        }

        .connector {
            width: 14px;
            height: 14px;
            background: #3498db;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            z-index: 10;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .connector:hover {
            background: #2980b9;
            transform: scale(1.2);
        }

        .connector.active {
            background: #e74c3c;
            transform: scale(1.3);
        }

        .connector-top {
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector-right {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector-bottom {
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector-left {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1001;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-button {
            background: #205295;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background: #2c70b4;
        }

        .legend {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 900;
        }

        .legend h4 {
            margin-top: 0;
            color: #205295;
            font-size: 1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .legend ul {
            margin: 0;
            padding-left: 15px;
            font-size: 0.9em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            .box {
                max-width: 300px;
                font-size: 14px;
            }

            .legend {
                max-width: 250px;
                font-size: 12px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.5/leader-line.min.js"></script>
</head>

<body>
    <!-- 프로세스 범례 -->
    <div class="legend">
        <h4>의장공정 4단계 업무 프로세스</h4>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #3498db;"></div>
            <span>1. 수신 단계 (데이터 입수 및 검증)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e67e22;"></div>
            <span>2. 편성 단계 (데이터 구조화 및 작업 준비)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #2ecc71;"></div>
            <span>3. 조회 단계 (작업 지시 확인 및 조정)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #9b59b6;"></div>
            <span>4. 서열지 출력/이종확인 단계 (실행 및 검증)</span>
        </div>
    </div>

    <!-- 업무 프로세스 박스 구조 -->
    <div class="boxs" id="container">
        <!-- 1단계: 수신 단계 -->
        <div class="box receiving" style="top: 0px; left: 0px;">
            <h4>1-1. 데이터 소스 연결</h4>
            <p>TCP/IP 통신 채널 확립 및 통신 파라미터 설정, 수신 버퍼 초기화</p>
        </div>

        <div class="box receiving" style="top: 0px; left: 400px;">
            <h4>1-2. 생산 데이터 수신</h4>
            <p>TCP 통신을 통한 패킷 데이터 수신 (PBS OUT 데이터, 생산계획 데이터)</p>
        </div>

        <div class="box receiving" style="top: 0px; left: 800px;">
            <h4>1-3. 데이터 검증 및 변환</h4>
            <p>Checksum 확인, 데이터 포맷 검증, TSQ011 트랜잭션 처리</p>
        </div>

        <div class="box receiving" style="top: 0px; left: 1200px;">
            <h4>1-4. 원본 데이터 백업</h4>
            <p>수신원본 저장, 시간/일자별 아카이빙, 백업 이력 DB 업데이트</p>
        </div>

        <div class="box receiving" style="top: 0px; left: 1600px;">
            <h4>1-5. 수신 완료 통보</h4>
            <p>소스 시스템에 ACK 전송, 수신 로그 기록, 관리자 알림</p>
        </div>
        
        <!-- 2단계: 편성 단계 -->
        <div class="box sequencing" style="top: 300px; left: 0px;">
            <h4>2-1. 편성 프로그램 초기화</h4>
            <p>전용 편성 프로그램 실행, 파라미터 설정 (차종, 라인, 작업일자)</p>
        </div>

        <div class="box sequencing" style="top: 300px; left: 400px;">
            <h4>2-2. 마스터 데이터 로딩</h4>
            <p>품목마스터 정보 로딩, BOM 정보 참조, 부품 정보 확인</p>
        </div>

        <div class="box sequencing" style="top: 300px; left: 800px;">
            <h4>2-3. 데이터 편성 작업 수행</h4>
            <p>품목마스터 매핑, 차대번호별 부품 리스트, 작업 우선순위 결정</p>
        </div>

        <div class="box sequencing" style="top: 300px; left: 1200px;">
            <h4>2-4. 배치(파레트) 편성</h4>
            <p>배치 단위 설정, 품목-배치 연결, 생산 순서 최적화</p>
        </div>

        <div class="box sequencing" style="top: 300px; left: 1600px;">
            <h4>2-5. 편성 결과 저장</h4>
            <p>서열정보 DB 저장, 배치정보 구조화 (Head/Detail), 이력 관리</p>
        </div>
        
        <div class="box sequencing" style="top: 300px; left: 2000px;">
            <h4>2-6. 편성 결과 검증</h4>
            <p>작업 지시 유효성 검사, 리소스 충돌 검토, 오류 교정</p>
        </div>
        
        <!-- 3단계: 조회 단계 -->
        <div class="box viewing" style="top: 600px; left: 0px;">
            <h4>3-1. 조회 시스템 접속</h4>
            <p>사용자 인증 및 권한 확인, 조회 화면 초기화, 파라미터 설정</p>
        </div>

        <div class="box viewing" style="top: 600px; left: 400px;">
            <h4>3-2. 편성 정보 로딩</h4>
            <p>DB 쿼리 실행, 차종/라인별 필터링, 작업일자/교대조별 분류</p>
        </div>

        <div class="box viewing" style="top: 600px; left: 800px;">
            <h4>3-3. 작업 지시 내용 확인</h4>
            <p>서열 정보 시각화, KPI 표시, 작업량/부하 분석 확인</p>
        </div>

        <div class="box viewing" style="top: 600px; left: 1200px;">
            <h4>3-4. 오류 및 특이사항 점검</h4>
            <p>데이터 불일치 확인, 부품 수급 상황 검토, 설비/인력 현황 확인</p>
        </div>

        <div class="box viewing" style="top: 600px; left: 1600px;">
            <h4>3-5. 필요시 조정 작업</h4>
            <p>수동 서열 조정, 우선순위 변경, 조정 이력 기록, 승인 진행</p>
        </div>
        
        <div class="box viewing" style="top: 600px; left: 2000px;">
            <h4>3-6. 조정 결과 확정</h4>
            <p>조정된 작업 지시 저장, 관련 부서 통보, 변경 이력 관리</p>
        </div>
        
        <!-- 4단계: 서열지 출력/이종확인 단계 -->
        <div class="box printing" style="top: 900px; left: 0px;">
            <h4>4-1. 서열지 출력 준비</h4>
            <p>출력 시스템 점검, 프린터 설정, 출력 양식 로딩</p>
        </div>

        <div class="box printing" style="top: 900px; left: 400px;">
            <h4>4-2. 서열지 생성 및 출력</h4>
            <p>작업 지시서 변환, 레이아웃 적용, 바코드/QR코드 생성, 출력</p>
        </div>

        <div class="box printing" style="top: 900px; left: 800px;">
            <h4>4-3. DCS 인터페이스 전송</h4>
            <p>Distribution Control System 연결, 데이터 패키징, 전송 처리</p>
        </div>

        <div class="box printing" style="top: 900px; left: 1200px;">
            <h4>4-4. 이종확인 작업 준비</h4>
            <p>스캐너 초기화, 작업자 인증, 확인 대상 정보 로딩</p>
        </div>

        <div class="box printing" style="top: 900px; left: 1600px;">
            <h4>4-5. 부품과 서열지 정보 대조</h4>
            <p>바코드/RFID 스캔, 일치 여부 확인, 불일치 경고 및 처리</p>
        </div>
        
        <div class="box printing" style="top: 900px; left: 2000px;">
            <h4>4-6. 이력 저장 및 후속 처리</h4>
            <p>확인 결과 DB 저장, 품질 시스템 연동, 조치 계획 수립</p>
        </div>
        
        <div class="box printing" style="top: 900px; left: 2400px;">
            <h4>4-7. 차종/라인별 유연 프로세스</h4>
            <p>차종별 순서 조정, 특수 차종 프로세스, 실시간 최적화</p>
        </div>

        <!-- 특별 의장 공정 관련 추가 박스 -->
        <div class="box" style="top: 1200px; left: 0px;">
            <h4>트림 라인 의장 작업</h4>
            <p>내장재, 와이어링 하네스, 유리 등 설치 작업 지시</p>
        </div>
        
        <div class="box" style="top: 1200px; left: 400px;">
            <h4>샤시 라인 의장 작업</h4>
            <p>엔진, 변속기, 서스펜션 등 장착 작업 지시</p>
        </div>
        
        <div class="box" style="top: 1200px; left: 800px;">
            <h4>파이널 라인 의장 작업</h4>
            <p>도어, 범퍼, 휠 등 최종 조립 작업 지시</p>
        </div>
        
        <div class="box" style="top: 1200px; left: 1200px;">
            <h4>의장 품질 검사</h4>
            <p>조립 품질 및 기능 점검, 외관 검사 작업 관리</p>
        </div>
        
        <div class="box" style="top: 1200px; left: 1600px;">
            <h4>의장 작업 모니터링</h4>
            <p>실시간 작업 현황 모니터링, 지연/오류 알림, 실적 집계</p>
        </div>
        
        <div class="box" style="top: 1200px; left: 2000px;">
            <h4>의장 공정 리워크</h4>
            <p>조립 불량 수정 작업, 리워크 이력 관리, 품질 피드백</p>
        </div>

        <div class="tooltip" id="tooltip"></div>

        <div class="controls">
            <button id="resetBtn" class="control-button">레이아웃 초기화</button>
            <button id="resetConnectionsBtn" class="control-button">연결 초기화</button>
        </div>
    </div>
    <script>
        (() => {
            // 전역 상태 관리
            const state = {
                connections: new Map(),
                dragStart: null,
                tempLine: null,
                isDraggingBox: false,
                draggedBox: null,
                initialMouseX: 0,
                initialMouseY: 0,
                initialBoxX: 0,
                initialBoxY: 0,
                tooltip: document.getElementById('tooltip'),
                initialBoxPositions: new Map()
            };

            // 모바일 기기 감지
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            // 초기 박스 위치 저장
            const saveInitialBoxPositions = () => {
                document.querySelectorAll('.box').forEach(box => {
                    const title = box.querySelector('h4').textContent.trim();
                    state.initialBoxPositions.set(title, {
                        top: box.offsetTop,
                        left: box.offsetLeft
                    });
                });
            };

            const resetBoxPositions = () => {
                document.querySelectorAll('.box').forEach(box => {
                    const title = box.querySelector('h4').textContent.trim();
                    const position = state.initialBoxPositions.get(title);
                    if (position) {
                        box.style.top = `${position.top}px`;
                        box.style.left = `${position.left}px`;
                    }
                });
                // 연결선 위치 업데이트
                state.connections.forEach(conn => conn.line.position());
            };

            // 툴팁 표시 함수
            const showTooltip = (text, x, y) => {
                state.tooltip.textContent = text;
                state.tooltip.style.left = `${x}px`;
                state.tooltip.style.top = `${y}px`;
                state.tooltip.style.opacity = '1';
            };

            // 툴팁 숨기기 함수
            const hideTooltip = () => {
                state.tooltip.style.opacity = '0';
            };

            // 커넥터 초기화 함수 (이벤트 델리게이션 적용)
            const initConnectors = () => {
                document.querySelectorAll('.box').forEach(box => {
                    ['top', 'right', 'bottom', 'left'].forEach(pos => {
                        const connector = document.createElement('div');
                        connector.className = `connector connector-${pos}`;
                        connector.dataset.socket = pos;
                        connector.dataset.parent = box.querySelector('h4').textContent.trim();
                        connector.title = `${box.querySelector('h4').textContent} ${pos} 연결점`;
                        box.appendChild(connector);
                    });
                });
            };

            // 임시 연결선 생성 함수
            const createTempLine = (connector, endpoint) => {
                return new LeaderLine(
                    LeaderLine.pointAnchor(connector, { x: '50%', y: '50%' }),
                    endpoint,
                    {
                        path: 'grid',  // 임시선은 항상 grid 경로 사용
                        color: '#205295',
                        size: 2,
                        startPlug: 'disc',
                        endPlug: 'arrow1',
                        dash: true,
                        startSocket: connector.dataset.socket,
                        startSocketGravity: 80,
                        endSocketGravity: 80
                    }
                );
            };

            // 연결 생성 함수 - 박스를 확실히 피해가는 연결선
            const createConnection = (start, end) => {
                // 중복 연결 확인
                const connectionKey = `${start.dataset.parent}-${start.dataset.socket}-${end.dataset.parent}-${end.dataset.socket}`;
                if (state.connections.has(connectionKey)) {
                    return null;
                }

                // 선 생성 옵션
                const lineOptions = {
                    color: '#205295',
                    size: 2,
                    startPlug: 'disc',
                    endPlug: 'arrow1',
                    startPlugSize: 1.5,
                    endPlugSize: 1.5,
                    dash: false,
                    dropShadow: false,
                    startSocket: start.dataset.socket,
                    endSocket: end.dataset.socket
                };

                // 시작점과 끝점의 방향에 따라 적절한 경로 유형 선택
                const startSocket = start.dataset.socket;
                const endSocket = end.dataset.socket;

                // 박스 간 상대적 위치 확인
                const startBox = start.closest('.box');
                const endBox = end.closest('.box');
                const startRect = startBox.getBoundingClientRect();
                const endRect = endBox.getBoundingClientRect();

                // 방향 판단: 상하좌우 또는 대각선
                const isVertical =
                    (startSocket === 'bottom' && endSocket === 'top') ||
                    (startSocket === 'top' && endSocket === 'bottom');
                const isHorizontal =
                    (startSocket === 'right' && endSocket === 'left') ||
                    (startSocket === 'left' && endSocket === 'right');
                const isOpposite =
                    (startSocket === 'top' && endSocket === 'top') ||
                    (startSocket === 'bottom' && endSocket === 'bottom') ||
                    (startSocket === 'left' && endSocket === 'left') ||
                    (startSocket === 'right' && endSocket === 'right');

                // 직선 경로를 사용할 수 있는 경우 (박스 사이에 다른 박스가 없음)
                let useDirectPath = true;

                // 모든 박스를 순회하며 시작점과 끝점 사이에 다른 박스가 있는지 확인
                document.querySelectorAll('.box').forEach(box => {
                    if (box === startBox || box === endBox) return;

                    const boxRect = box.getBoundingClientRect();

                    // 두 박스 사이의 영역과 현재 박스가 겹치는지 확인
                    const isInBetween = (
                        // 수평 방향으로 겹침
                        ((boxRect.left < Math.max(startRect.right, endRect.right) &&
                            boxRect.right > Math.min(startRect.left, endRect.left)) &&
                            // 수직 방향으로 겹침
                            (boxRect.top < Math.max(startRect.bottom, endRect.bottom) &&
                                boxRect.bottom > Math.min(startRect.top, endRect.top)))
                    );

                    if (isInBetween) {
                        useDirectPath = false;
                    }
                });

                // 경로 유형 결정
                if (useDirectPath && (isVertical || isHorizontal)) {
                    // 직접 연결이 가능한 경우 (간단한 직선)
                    lineOptions.path = 'straight';
                } else if (isOpposite) {
                    // 같은 방향의 커넥터를 연결할 때 (arc로 우회)
                    lineOptions.path = 'arc';
                    lineOptions.startSocketGravity = 50;
                    lineOptions.endSocketGravity = 50;
                } else {
                    // 복잡한 경로가 필요한 경우 (grid 방식으로 직각 연결)
                    lineOptions.path = 'grid';
                    lineOptions.startSocketGravity = 80;
                    lineOptions.endSocketGravity = 80;

                    // 대각선 방향일 때 더 확실한 우회 경로
                    if (!isVertical && !isHorizontal) {
                        lineOptions.gridBreak = '50%';
                    }
                }

                // 연결선 생성
                const line = new LeaderLine(
                    LeaderLine.pointAnchor(start, { x: '50%', y: '50%' }),
                    LeaderLine.pointAnchor(end, { x: '50%', y: '50%' }),
                    lineOptions
                );

                state.connections.set(connectionKey, {
                    line,
                    start,
                    end,
                    startBoxId: start.dataset.parent,
                    endBoxId: end.dataset.parent
                });

                // 연결에 애니메이션 효과 추가
                line.dash = { animation: true };
                setTimeout(() => {
                    line.dash = false;
                }, 500);

                return line;
            };

            // 커넥터로 연결 제거 함수
            const removeConnectionByConnector = connector => {
                [...state.connections.entries()].forEach(([key, conn]) => {
                    if (conn.start === connector || conn.end === connector) {
                        conn.line.remove();
                        state.connections.delete(key);
                    }
                });
            };

            // 커넥터로 연결 찾기 함수
            const getConnectionByConnector = connector => {
                return [...state.connections.entries()].find(([, conn]) =>
                    conn.start === connector || conn.end === connector
                );
            };

            // 모든 연결 초기화 함수
            const resetAllConnections = () => {
                state.connections.forEach(conn => {
                    conn.line.remove();
                });
                state.connections.clear();
                createInitialConnections();
            };

            // 박스 드래깅 초기화 함수 (이벤트 델리게이션 적용)
            const initBoxDragging = () => {
                const container = document.getElementById('container');

                // 이벤트 타입 결정 (모바일 vs 데스크톱)
                const startEvent = isMobile ? 'touchstart' : 'mousedown';
                const moveEvent = isMobile ? 'touchmove' : 'mousemove';
                const endEvent = isMobile ? 'touchend' : 'mouseup';

                // 마우스다운/터치스타트 이벤트 (델리게이션)
                container.addEventListener(startEvent, e => {
                    if (e.target.classList.contains('connector') || e.target.classList.contains('control-button') || e.target.classList.contains('phase-title')) {
                        return;
                    }

                    const box = e.target.closest('.box');
                    if (!box) return;

                    e.preventDefault();

                    state.isDraggingBox = true;
                    state.draggedBox = box;

                    const pageX = isMobile ? e.touches[0].clientX : e.clientX;
                    const pageY = isMobile ? e.touches[0].clientY : e.clientY;

                    state.initialMouseX = pageX;
                    state.initialMouseY = pageY;
                    state.initialBoxX = box.offsetLeft;
                    state.initialBoxY = box.offsetTop;

                    box.classList.add('dragging');
                });

                // 마우스무브/터치무브 이벤트
                document.addEventListener(moveEvent, e => {
                    if (state.isDraggingBox && state.draggedBox) {
                        const pageX = isMobile ? e.touches[0].clientX : e.clientX;
                        const pageY = isMobile ? e.touches[0].clientY : e.clientY;

                        const deltaX = pageX - state.initialMouseX;
                        const deltaY = pageY - state.initialMouseY;

                        state.draggedBox.style.left = `${state.initialBoxX + deltaX}px`;
                        state.draggedBox.style.top = `${state.initialBoxY + deltaY}px`;

                        // 연결된 모든 선 업데이트
                        state.connections.forEach(conn => conn.line.position());
                    }
                });

                // 마우스업/터치엔드 이벤트
                document.addEventListener(endEvent, () => {
                    if (state.draggedBox) {
                        state.draggedBox.classList.remove('dragging');
                        state.draggedBox = null;
                    }
                    state.isDraggingBox = false;
                });
            };

            // 이벤트 초기화 함수 (델리게이션 적용)
            const initEvents = () => {
                const container = document.getElementById('container');

                // 커넥터 마우스다운/터치스타트 이벤트 (델리게이션)
                container.addEventListener(isMobile ? 'touchstart' : 'mousedown', e => {
                    const connector = e.target.closest('.connector');
                    if (!connector) return;

                    e.stopPropagation();
                    state.dragStart = connector;

                    // 기존 연결 제거
                    const existingConn = getConnectionByConnector(state.dragStart);
                    if (existingConn) {
                        existingConn[1].line.remove();
                        state.connections.delete(existingConn[0]);
                    }

                    // 시작점 좌표 가져오기
                    const rect = connector.getBoundingClientRect();
                    const startX = rect.left + rect.width / 2;
                    const startY = rect.top + rect.height / 2;

                    // 임시 연결선 생성
                    const initialEnd = isMobile ? {
                        x: e.touches[0].pageX,
                        y: e.touches[0].pageY
                    } : {
                        x: e.pageX,
                        y: e.pageY
                    };

                    // 임시 연결선 생성 함수 호출
                    state.tempLine = createTempLine(state.dragStart, initialEnd);

                    connector.classList.add('active');

                    // 툴팁 표시
                    const parentBox = connector.closest('.box');
                    const parentTitle = parentBox.querySelector('h4').textContent;
                    showTooltip(`${parentTitle}에서 연결 시작`, initialEnd.x + 15, initialEnd.y + 15);
                });

                // 마우스무브/터치무브 이벤트
                document.addEventListener(isMobile ? 'touchmove' : 'mousemove', e => {
                    if (state.tempLine) {
                        const pageX = isMobile ? e.touches[0].pageX : e.pageX;
                        const pageY = isMobile ? e.touches[0].pageY : e.pageY;

                        state.tempLine.setOptions({ end: { x: pageX, y: pageY } });

                        // 툴팁 위치 업데이트
                        state.tooltip.style.left = `${pageX + 15}px`;
                        state.tooltip.style.top = `${pageY + 15}px`;
                    }
                });

                // 마우스업/터치엔드 이벤트
                document.addEventListener(isMobile ? 'touchend' : 'mouseup', e => {
                    if (!state.dragStart) return;

                    // 모바일에서는 직접 target을 가져올 수 없으므로 좌표를 기반으로 요소 찾기
                    let targetElement;
                    if (isMobile && e.changedTouches && e.changedTouches.length > 0) {
                        const touch = e.changedTouches[0];
                        targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                    } else {
                        targetElement = e.target;
                    }

                    const dragEnd = targetElement ? targetElement.closest('.connector') : null;

                    if (dragEnd && state.dragStart !== dragEnd) {
                        // 성공적으로 연결 생성
                        createConnection(state.dragStart, dragEnd);

                        // 성공 툴팁 표시
                        const startBox = state.dragStart.closest('.box').querySelector('h4').textContent;
                        const endBox = dragEnd.closest('.box').querySelector('h4').textContent;
                        showTooltip(`${startBox}에서 ${endBox}로 연결됨`, e.pageX + 15, e.pageY + 15);
                        setTimeout(hideTooltip, 1500);
                    } else if (!dragEnd) {
                        // 연결 삭제 또는 실패
                        removeConnectionByConnector(state.dragStart);

                        // 실패 툴팁 표시
                        showTooltip('연결 취소됨', e.pageX + 15, e.pageY + 15);
                        setTimeout(hideTooltip, 1500);
                    }

                    if (state.tempLine) {
                        state.tempLine.remove();
                        state.tempLine = null;
                    }

                    state.dragStart.classList.remove('active');
                    state.dragStart = null;
                });

                // 컨텍스트 메뉴 이벤트 (연결 제거)
                document.addEventListener('contextmenu', e => {
                    const connector = e.target.closest('.connector');
                    if (connector) {
                        e.preventDefault();
                        removeConnectionByConnector(connector);

                        // 삭제 툴팁 표시
                        showTooltip('연결이 삭제되었습니다', e.pageX + 15, e.pageY + 15);
                        setTimeout(hideTooltip, 1500);
                    }
                });

                // 창 크기 변경 이벤트
                window.addEventListener('resize', () => {
                    // 리사이즈 디바운스 적용
                    if (state.resizeTimeout) {
                        clearTimeout(state.resizeTimeout);
                    }

                    state.resizeTimeout = setTimeout(() => {
                        state.connections.forEach(conn => conn.line.position());
                    }, 100);
                });

                // 컨트롤 버튼 이벤트
                document.getElementById('resetBtn').addEventListener('click', resetBoxPositions);
                document.getElementById('resetConnectionsBtn').addEventListener('click', resetAllConnections);

                // 커넥터에 호버 효과 추가
                container.addEventListener('mouseover', e => {
                    const connector = e.target.closest('.connector');
                    if (connector && !state.dragStart) {
                        const boxTitle = connector.closest('.box').querySelector('h4').textContent;
                        const position = connector.dataset.socket;

                        // 연결 수 확인
                        let connectionCount = 0;
                        state.connections.forEach(conn => {
                            if (conn.start === connector || conn.end === connector) {
                                connectionCount++;
                            }
                        });

                        const tooltip = connectionCount > 0
                            ? `${boxTitle} ${position} 연결 (${connectionCount}개 연결됨)`
                            : `${boxTitle} ${position} 연결점`;

                        const rect = connector.getBoundingClientRect();
                        showTooltip(tooltip, rect.right + 10, rect.top);
                    }
                });

                container.addEventListener('mouseout', e => {
                    const connector = e.target.closest('.connector');
                    if (connector && !state.dragStart) {
                        hideTooltip();
                    }
                });
            };

            // 초기 연결 관계 생성 함수 - 의장공정 4단계 업무 프로세스 흐름
            const createInitialConnections = () => {
                // 커넥터 찾기 헬퍼 함수 - h4 제목 기준
                const findConnector = (boxTitle, position) => {
                    const box = Array.from(document.querySelectorAll('.box')).find(
                        b => b.querySelector('h4').textContent.trim() === boxTitle
                    );
                    return box ? box.querySelector(`.connector-${position}`) : null;
                };

                // 의장 공정 업무 프로세스에 맞게 교정된 연결 정의
                const initialConnections = [
                    // 1단계: 수신 단계 내 연결
                    [findConnector('1-1. 데이터 소스 연결', 'right'), findConnector('1-2. 생산 데이터 수신', 'left')],
                    [findConnector('1-2. 생산 데이터 수신', 'right'), findConnector('1-3. 데이터 검증 및 변환', 'left')],
                    [findConnector('1-3. 데이터 검증 및 변환', 'right'), findConnector('1-4. 원본 데이터 백업', 'left')],
                    [findConnector('1-4. 원본 데이터 백업', 'right'), findConnector('1-5. 수신 완료 통보', 'left')],
                    
                    // 1단계에서 2단계로 연결
                    [findConnector('1-5. 수신 완료 통보', 'bottom'), findConnector('2-1. 편성 프로그램 초기화', 'top')],
                    
                    // 2단계: 편성 단계 내 연결
                    [findConnector('2-1. 편성 프로그램 초기화', 'right'), findConnector('2-2. 마스터 데이터 로딩', 'left')],
                    [findConnector('2-2. 마스터 데이터 로딩', 'right'), findConnector('2-3. 데이터 편성 작업 수행', 'left')],
                    [findConnector('2-3. 데이터 편성 작업 수행', 'right'), findConnector('2-4. 배치(파레트) 편성', 'left')],
                    [findConnector('2-4. 배치(파레트) 편성', 'right'), findConnector('2-5. 편성 결과 저장', 'left')],
                    [findConnector('2-5. 편성 결과 저장', 'right'), findConnector('2-6. 편성 결과 검증', 'left')],
                    
                    // 2단계에서 3단계로 연결
                    [findConnector('2-6. 편성 결과 검증', 'bottom'), findConnector('3-1. 조회 시스템 접속', 'top')],
                    
                    // 3단계: 조회 단계 내 연결
                    [findConnector('3-1. 조회 시스템 접속', 'right'), findConnector('3-2. 편성 정보 로딩', 'left')],
                    [findConnector('3-2. 편성 정보 로딩', 'right'), findConnector('3-3. 작업 지시 내용 확인', 'left')],
                    [findConnector('3-3. 작업 지시 내용 확인', 'right'), findConnector('3-4. 오류 및 특이사항 점검', 'left')],
                    [findConnector('3-4. 오류 및 특이사항 점검', 'right'), findConnector('3-5. 필요시 조정 작업', 'left')],
                    [findConnector('3-5. 필요시 조정 작업', 'right'), findConnector('3-6. 조정 결과 확정', 'left')],
                    
                    // 3단계에서 4단계로 연결
                    [findConnector('3-6. 조정 결과 확정', 'bottom'), findConnector('4-1. 서열지 출력 준비', 'top')],
                    
                    // 4단계: 서열지 출력/이종확인 단계 내 연결
                    [findConnector('4-1. 서열지 출력 준비', 'right'), findConnector('4-2. 서열지 생성 및 출력', 'left')],
                    [findConnector('4-2. 서열지 생성 및 출력', 'right'), findConnector('4-3. DCS 인터페이스 전송', 'left')],
                    [findConnector('4-3. DCS 인터페이스 전송', 'right'), findConnector('4-4. 이종확인 작업 준비', 'left')],
                    [findConnector('4-4. 이종확인 작업 준비', 'right'), findConnector('4-5. 부품과 서열지 정보 대조', 'left')],
                    [findConnector('4-5. 부품과 서열지 정보 대조', 'right'), findConnector('4-6. 이력 저장 및 후속 처리', 'left')],
                    [findConnector('4-6. 이력 저장 및 후속 처리', 'right'), findConnector('4-7. 차종/라인별 유연 프로세스', 'left')],
                    
                    // 4단계에서 의장 작업으로 연결
                    [findConnector('4-2. 서열지 생성 및 출력', 'bottom'), findConnector('트림 라인 의장 작업', 'top')],
                    [findConnector('4-2. 서열지 생성 및 출력', 'bottom'), findConnector('샤시 라인 의장 작업', 'top')],
                    [findConnector('4-2. 서열지 생성 및 출력', 'bottom'), findConnector('파이널 라인 의장 작업', 'top')],
                    
                    // 의장 작업 간 연결
                    [findConnector('트림 라인 의장 작업', 'right'), findConnector('샤시 라인 의장 작업', 'left')],
                    [findConnector('샤시 라인 의장 작업', 'right'), findConnector('파이널 라인 의장 작업', 'left')],
                    [findConnector('파이널 라인 의장 작업', 'right'), findConnector('의장 품질 검사', 'left')],
                    [findConnector('의장 품질 검사', 'right'), findConnector('의장 작업 모니터링', 'left')],
                    [findConnector('의장 작업 모니터링', 'right'), findConnector('의장 공정 리워크', 'left')],
                    
                    // 피드백 루프
                    [findConnector('의장 공정 리워크', 'top'), findConnector('3-5. 필요시 조정 작업', 'bottom')],
                    [findConnector('의장 품질 검사', 'top'), findConnector('4-5. 부품과 서열지 정보 대조', 'bottom')],
                    [findConnector('의장 작업 모니터링', 'top'), findConnector('3-3. 작업 지시 내용 확인', 'bottom')]
                ];

                // 각 연결 생성
                initialConnections.forEach(([start, end]) => {
                    if (start && end) {
                        createConnection(start, end);
                    } else {
                        console.warn('연결점을 찾을 수 없습니다.', start, end);
                    }
                });
            };

            // 페이지 로드 시 초기화
            window.addEventListener('DOMContentLoaded', () => {
                // 툴팁 엘리먼트 생성
                if (!document.getElementById('tooltip')) {
                    const tooltip = document.createElement('div');
                    tooltip.id = 'tooltip';
                    tooltip.className = 'tooltip';
                    document.body.appendChild(tooltip);
                    state.tooltip = tooltip;
                }

                initConnectors();
                initBoxDragging();
                initEvents();
                saveInitialBoxPositions();

                // 페이지 로드 후 1초 후에 초기 연결 생성 (DOM이 완전히 렌더링 된 후)
                setTimeout(createInitialConnections, 1000);
            });
        })(); 
    </script>
</body>

</html>