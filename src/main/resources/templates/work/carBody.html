<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>현대자동차 울산공장 프로세스 연결 시스템 - 개선버전</title>
    <style>
        body {
            font-family: 'Noto Sans KR', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .boxs {
            display: block;
            padding: 20px;
            position: relative;
            min-height: 250vh;
            width: 100%;
            box-sizing: border-box;
        }

        .box {
            min-width: 300px;
            max-width: 300px;
            min-height: 200px;
            width: auto;
            height: auto;
            border: 2px solid #2c3e50;
            border-radius: 8px;
            background: #ffffff;
            position: absolute;
            user-select: none;
            cursor: move;
            overflow: visible;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.3s ease, transform 0.1s ease;
        }

        .box:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .box.dragging {
            transform: scale(1.02);
            opacity: 0.9;
            z-index: 1000;
        }

        .box h4 {
            margin-top: 0;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            color: #205295;
            font-size: 1.1em;
        }

        .box ul,
        .box ol {
            margin: 0;
            padding-left: 20px;
            line-height: 1.5;
        }

        .box p {
            margin: 10px 0;
            line-height: 1.5;
        }

        /* 로봇 시스템 및 특수 박스 스타일 */
        .robot-box {
            background-color: #f8f9fa;
            border-color: #e74c3c;
        }

        .robot-box h4 {
            color: #c0392b;
        }

        .system-box {
            background-color: #eefbff;
            border-color: #3498db;
        }

        .system-box h4 {
            color: #2980b9;
        }

        .robot-grid {
            min-width: 400px;
            max-width: 400px;
            background-color: #f5f5f5;
            border: 2px solid #7f8c8d;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 10px;
            padding: 15px;
        }

        .robot-cell {
            min-height: 60px;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .robot-cell:hover {
            background-color: #ecf0f1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .connector {
            width: 14px;
            height: 14px;
            background: #3498db;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            z-index: 10;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        .connector:hover {
            background: #2980b9;
            transform: scale(1.2);
        }

        .connector.active {
            background: #e74c3c;
            transform: scale(1.3);
        }

        .connector-top {
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector-right {
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector-bottom {
            bottom: -7px;
            left: 50%;
            transform: translateX(-50%);
        }

        .connector-left {
            left: -7px;
            top: 50%;
            transform: translateY(-50%);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1001;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-button {
            background: #205295;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background: #2c70b4;
        }

        .legend {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 900;
        }

        .legend h4 {
            margin-top: 0;
            color: #205295;
            font-size: 1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .legend ul {
            margin: 0;
            padding-left: 15px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .box {
                max-width: 300px;
                font-size: 14px;
            }

            .legend {
                max-width: 250px;
                font-size: 12px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leader-line@1.0.5/leader-line.min.js"></script>
</head>

<body>
    <div class="boxs" id="container">
        <!-- 기본 프로세스 박스 -->
        <div class="box" style="top: 0px; left: 0px;">
            <h4>고객 주문</h4>
        </div>

        <div class="box" style="top: 0px; left: 500px;">
            <h4>생산 관리부</h4>
            <ul>
                <li>1~5공장</li>
                <li>생산계획</li>
            </ul>
        </div>

        <div class="box" style="top: 300px; left: 0px;">
            <h4>Glovis</h4>
        </div>

        <div class="box" style="top: 300px; left: 500px;">
            <h4>실행사</h4>
        </div>

        <div class="box" style="top: 0px; left: 1000px;">
            <h4>제조사</h4>
        </div>

        <div class="box" style="top: 600px; left: 0px;">
            <h4>서열 작업</h4>
        </div>

        <div class="box" style="top: 600px; left: 500px;">
            <h4>서열지 출력</h4>
        </div>

        <div class="box" style="top: 300px; left: 1000px;">
            <h4>수작업</h4>
        </div>

        <div class="box robot-box" style="top: 600px; left: 1000px;">
            <h4>로봇 작업</h4>
            <p>자동화 로봇 시스템</p>
        </div>

        <!-- RR FLR 로봇 시스템 -->
        <div class="box robot-box" style="top: 900px; left: 0px;">
            <h4>RR FLR</h4>
            <div class="robot-grid">
                <div class="robot-cell">1</div>
                <div class="robot-cell">2</div>
                <div class="robot-cell">3</div>
                <div class="robot-cell">4</div>
                <div class="robot-cell">5</div>
                <div class="robot-cell">6</div>
                <div class="robot-cell">7</div>
                <div class="robot-cell">출고</div>
            </div>
            <p>로봇 작업 스테이션</p>
        </div>

        <!-- PBS 시스템 -->
        <div class="box system-box" style="top: 900px; left: 500px;">
            <h4>PBS</h4>
            <p>생산 관리 시스템</p>
        </div>

        <!-- 컨베이어 시스템 -->
        <div class="box system-box" style="top: 900px; left: 1000px;">
            <h4>컨베이어(CTS)</h4>
            <p>자동 부품 이송 시스템</p>
        </div>

        <!-- PLC 컨트롤러 -->
        <div class="box system-box" style="top: 900px; left: 1500px;">
            <h4>PLC</h4>
            <p>프로그래머블 로직 컨트롤러</p>
        </div>

        <!-- PC 시스템 -->
        <div class="box system-box" style="top: 1200px; left: 500px;">
            <h4>PC</h4>
            <p>제어 시스템</p>
        </div>

        <!-- FAC 시스템 -->
        <div class="box system-box" style="top: 1200px; left: 1000px;">
            <h4>FAC</h4>
            <p>공장 자동화 제어</p>
            <ul>
                <li>FTP 전송 프로그램</li>
                <li>서열정보 출력</li>
                <li>작업 일시 기록 모듈</li>
            </ul>
        </div>

        <div class="legend">
            <h4>차체공정 프레스</h4>
            <ul>
                <li>수신 단계</li>
                <li>편성 단계</li>
                <li>재고 단계</li>
                <li>서열지 출력 단계</li>
                <li>로봇 작업 단계</li>
                <li>시스템 연동 단계</li>
            </ul>
        </div>

        <div class="controls">
            <button id="resetBtn" class="control-button">레이아웃 초기화</button>
            <button id="resetConnectionsBtn" class="control-button">연결 초기화</button>
        </div>
    </div>
    <script>
        /**
         * 현대자동차 울산공장 프로세스 연결 시스템 
         * 클래스 기반으로 리팩토링된 코드
         */
        (() => {
            /**
             * 프로세스 맵 색상 설정 클래스
             * 각 그룹별 색상 관리
             */
            class ColorScheme {
                constructor() {
                    this.colors = {
                        'process': '#205295',  // 기본 프로세스 색상
                        'robot': '#c0392b',     // 로봇 관련 색상
                        'system': '#2980b9'     // 시스템 관련 색상
                    };
                }

                /**
                 * 그룹에 해당하는 색상 반환
                 * @param {string} group - 색상을 조회할 그룹명
                 * @returns {string} 색상 코드
                 */
                getColor(group) {
                    return this.colors[group] || '#205295'; // 기본 색상
                }

                /**
                 * 박스 유형에 따른 그룹 결정
                 * @param {HTMLElement} box - 그룹을 확인할 박스 요소
                 * @returns {string} 그룹명
                 */
                getBoxGroup(box) {
                    if (box.classList.contains('robot-box')) {
                        return 'robot';
                    } else if (box.classList.contains('system-box')) {
                        return 'system';
                    }
                    return 'process';
                }
            }

            /**
             * 프로세스 맵 상태 관리 클래스
             * 전체 애플리케이션의 상태를 관리
             */
            class ProcessMapState {
                constructor() {
                    this.connections = new Map();
                    this.dragStart = null;
                    this.tempLine = null;
                    this.isDraggingBox = false;
                    this.draggedBox = null;
                    this.initialMouseX = 0;
                    this.initialMouseY = 0;
                    this.initialBoxX = 0;
                    this.initialBoxY = 0;
                    this.tooltip = null;
                    this.initialBoxPositions = new Map();
                    this.resizeTimeout = null;
                }

                /**
                 * 초기 박스 위치 저장
                 */
                saveInitialBoxPositions() {
                    document.querySelectorAll('.box').forEach(box => {
                        const title = box.querySelector('h4').textContent.trim();
                        this.initialBoxPositions.set(title, {
                            top: box.offsetTop,
                            left: box.offsetLeft
                        });
                    });
                }

                /**
                 * 박스 위치 초기화
                 */
                resetBoxPositions() {
                    document.querySelectorAll('.box').forEach(box => {
                        const title = box.querySelector('h4').textContent.trim();
                        const position = this.initialBoxPositions.get(title);
                        if (position) {
                            box.style.top = `${position.top}px`;
                            box.style.left = `${position.left}px`;
                        }
                    });
                    // 연결선 위치 업데이트
                    this.connections.forEach(conn => conn.line.position());
                }

                /**
                 * 툴팁 표시
                 * @param {string} text - 툴팁에 표시할 텍스트
                 * @param {number} x - 툴팁 X 좌표
                 * @param {number} y - 툴팁 Y 좌표
                 */
                showTooltip(text, x, y) {
                    if (!this.tooltip) return;
                    this.tooltip.textContent = text;
                    this.tooltip.style.left = `${x}px`;
                    this.tooltip.style.top = `${y}px`;
                    this.tooltip.style.opacity = '1';
                }

                /**
                 * 툴팁 숨기기
                 */
                hideTooltip() {
                    if (!this.tooltip) return;
                    this.tooltip.style.opacity = '0';
                }
            }

            /**
             * 커넥터 관리 클래스
             * 박스 연결점 생성 및 관리
             */
            class ConnectorManager {
                /**
                 * @param {ProcessMapState} state - 상태 관리 객체
                 * @param {ColorScheme} colorScheme - 색상 관리 객체
                 */
                constructor(state, colorScheme) {
                    this.state = state;
                    this.colorScheme = colorScheme;
                }

                /**
                 * 모든 박스에 커넥터 초기화
                 */
                initConnectors() {
                    document.querySelectorAll('.box').forEach(box => {
                        const group = this.colorScheme.getBoxGroup(box);
                        const connectorColor = this.colorScheme.getColor(group);

                        ['top', 'right', 'bottom', 'left'].forEach(pos => {
                            const connector = document.createElement('div');
                            connector.className = `connector connector-${pos}`;
                            connector.dataset.socket = pos;
                            connector.dataset.parent = box.querySelector('h4').textContent.trim();
                            connector.dataset.group = group;
                            connector.title = `${box.querySelector('h4').textContent} ${pos} 연결점`;

                            // 그룹별 커넥터 색상 적용
                            connector.style.backgroundColor = connectorColor;

                            box.appendChild(connector);
                        });
                    });
                }

                /**
                 * 커넥터로 연결 찾기
                 * @param {HTMLElement} connector - 연결을 찾을 커넥터 요소
                 * @returns {Array} 커넥터와 관련된 연결 항목
                 */
                getConnectionByConnector(connector) {
                    return [...this.state.connections.entries()].find(([, conn]) =>
                        conn.start === connector || conn.end === connector
                    );
                }

                /**
                 * 특정 커넥터 찾기
                 * @param {string} boxTitle - 박스 제목
                 * @param {string} position - 커넥터 위치
                 * @returns {HTMLElement|null} 찾은 커넥터 요소
                 */
                findConnector(boxTitle, position) {
                    const box = Array.from(document.querySelectorAll('.box')).find(
                        b => b.querySelector('h4').textContent.trim() === boxTitle
                    );
                    return box ? box.querySelector(`.connector-${position}`) : null;
                }
            }

            /**
             * 연결선 관리 클래스
             * 박스 간 연결선 생성 및 관리
             */
            class ConnectionManager {
                /**
                 * @param {ProcessMapState} state - 상태 관리 객체
                 * @param {ConnectorManager} connectorManager - 커넥터 관리 객체
                 * @param {ColorScheme} colorScheme - 색상 관리 객체
                 */
                constructor(state, connectorManager, colorScheme) {
                    this.state = state;
                    this.connectorManager = connectorManager;
                    this.colorScheme = colorScheme;
                }

                /**
                 * 임시 연결선 생성
                 * @param {HTMLElement} connector - 시작 커넥터
                 * @param {Object} endpoint - 끝점 좌표
                 * @returns {LeaderLine} 생성된 임시 연결선
                 */
                createTempLine(connector, endpoint) {
                    // 시작 커넥터의 그룹에 따른 색상 적용
                    const group = connector.dataset.group || 'process';
                    const lineColor = this.colorScheme.getColor(group);

                    return new LeaderLine(
                        LeaderLine.pointAnchor(connector, { x: '50%', y: '50%' }),
                        endpoint,
                        {
                            path: 'straight',
                            color: lineColor,
                            size: 2,
                            startPlug: 'disc',
                            endPlug: 'arrow1',
                            startPlugSize: 1.5,
                            endPlugSize: 1.5,
                            dash: true
                        }
                    );
                }

                /**
                 * 연결선 생성
                 * @param {HTMLElement} start - 시작 커넥터
                 * @param {HTMLElement} end - 끝 커넥터
                 * @returns {LeaderLine|null} 생성된 연결선
                 */
                createConnection(start, end) {
                    // 연결 키 생성: 시작박스명-시작포지션-끝박스명-끝포지션
                    const connectionKey = `${start.dataset.parent}-${start.dataset.socket}-${end.dataset.parent}-${end.dataset.socket}`;

                    // 중복 연결 확인
                    if (this.state.connections.has(connectionKey)) {
                        return null;
                    }

                    // 시작 커넥터의 그룹에 따른 색상 적용
                    const group = start.dataset.group || 'process';
                    const lineColor = this.colorScheme.getColor(group);

                    const line = new LeaderLine(
                        LeaderLine.pointAnchor(start, { x: '50%', y: '50%' }),
                        LeaderLine.pointAnchor(end, { x: '50%', y: '50%' }),
                        {
                            path: 'straight',
                            color: lineColor,
                            size: 2,
                            startPlug: 'disc',
                            endPlug: 'arrow1',
                            startPlugSize: 1.5,
                            endPlugSize: 1.5
                        }
                    );

                    this.state.connections.set(connectionKey, {
                        line,
                        start,
                        end,
                        startBoxId: start.dataset.parent,
                        endBoxId: end.dataset.parent,
                        group: group
                    });

                    // 연결에 애니메이션 효과 추가
                    line.dash = { animation: true };
                    setTimeout(() => {
                        line.dash = false;
                    }, 500);

                    return line;
                }

                /**
                 * 연결 제거
                 * @param {HTMLElement} connector - 연결을 제거할 커넥터
                 */
                removeConnectionByConnector(connector) {
                    [...this.state.connections.entries()].forEach(([key, conn]) => {
                        if (conn.start === connector || conn.end === connector) {
                            conn.line.remove();
                            this.state.connections.delete(key);
                        }
                    });
                }

                /**
                 * 모든 연결 초기화
                 */
                resetAllConnections() {
                    this.state.connections.forEach(conn => {
                        conn.line.remove();
                    });
                    this.state.connections.clear();
                    this.createInitialConnections();
                }

                /**
                 * 초기 연결 관계 생성
                 */
                createInitialConnections() {
                    // 초기 연결 정의 (박스 제목 기반)
                    const initialConnections = [
                        // 기본 프로세스 연결
                        ['고객 주문', 'right', '생산 관리부', 'left'],
                        ['생산 관리부', 'bottom', 'Glovis', 'top'],
                        ['Glovis', 'right', '실행사', 'left'],
                        ['제조사', 'left', '실행사', 'right'],
                        ['실행사', 'bottom', '서열 작업', 'top'],
                        ['서열 작업', 'right', '서열지 출력', 'left'],
                        ['서열지 출력', 'right', '수작업', 'left'],

                        // 로봇 작업 연결
                        ['서열지 출력', 'right', '로봇 작업', 'left'],
                        ['로봇 작업', 'bottom', 'RR FLR', 'top'],
                        ['로봇 작업', 'bottom', 'FAC', 'top'],

                        // RR FLR 시스템 연결
                        ['RR FLR', 'right', 'PBS', 'left'],
                        ['PBS', 'right', '컨베이어(CTS)', 'left'],
                        ['컨베이어(CTS)', 'right', 'PLC', 'left'],
                        ['컨베이어(CTS)', 'bottom', 'PC', 'top'],
                        ['PLC', 'bottom', 'FAC', 'top'],
                        ['PC', 'right', 'FAC', 'left'],
                    ];

                    // 각 연결 생성
                    initialConnections.forEach(([startTitle, startPos, endTitle, endPos]) => {
                        const start = this.connectorManager.findConnector(startTitle, startPos);
                        const end = this.connectorManager.findConnector(endTitle, endPos);

                        if (start && end) {
                            this.createConnection(start, end);
                        } else {
                            console.warn('연결점을 찾을 수 없습니다.', startTitle, startPos, endTitle, endPos);
                        }
                    });
                }
            }

            /**
             * 박스 드래깅 관리 클래스
             * 박스 이동 기능 관리
             */
            class BoxDragManager {
                /**
                 * @param {ProcessMapState} state - 상태 관리 객체
                 */
                constructor(state) {
                    this.state = state;
                    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                }

                /**
                 * 박스 드래깅 초기화
                 */
                initBoxDragging() {
                    const container = document.getElementById('container');

                    // 이벤트 타입 결정 (모바일 vs 데스크톱)
                    const startEvent = this.isMobile ? 'touchstart' : 'mousedown';
                    const moveEvent = this.isMobile ? 'touchmove' : 'mousemove';
                    const endEvent = this.isMobile ? 'touchend' : 'mouseup';

                    // 마우스다운/터치스타트 이벤트 (델리게이션)
                    container.addEventListener(startEvent, e => {
                        if (e.target.classList.contains('connector') ||
                            e.target.classList.contains('control-button') ||
                            e.target.classList.contains('robot-cell')) {
                            return;
                        }

                        const box = e.target.closest('.box');
                        if (!box) return;

                        e.preventDefault();

                        this.state.isDraggingBox = true;
                        this.state.draggedBox = box;

                        const pageX = this.isMobile ? e.touches[0].clientX : e.clientX;
                        const pageY = this.isMobile ? e.touches[0].clientY : e.clientY;

                        this.state.initialMouseX = pageX;
                        this.state.initialMouseY = pageY;
                        this.state.initialBoxX = box.offsetLeft;
                        this.state.initialBoxY = box.offsetTop;

                        box.classList.add('dragging');
                    });

                    // 마우스무브/터치무브 이벤트
                    document.addEventListener(moveEvent, e => {
                        if (this.state.isDraggingBox && this.state.draggedBox) {
                            const pageX = this.isMobile ? e.touches[0].clientX : e.clientX;
                            const pageY = this.isMobile ? e.touches[0].clientY : e.clientY;

                            const deltaX = pageX - this.state.initialMouseX;
                            const deltaY = pageY - this.state.initialMouseY;

                            this.state.draggedBox.style.left = `${this.state.initialBoxX + deltaX}px`;
                            this.state.draggedBox.style.top = `${this.state.initialBoxY + deltaY}px`;

                            // 연결된 모든 선 업데이트
                            this.state.connections.forEach(conn => conn.line.position());
                        }
                    });

                    // 마우스업/터치엔드 이벤트
                    document.addEventListener(endEvent, () => {
                        if (this.state.draggedBox) {
                            this.state.draggedBox.classList.remove('dragging');
                            this.state.draggedBox = null;
                        }
                        this.state.isDraggingBox = false;
                    });
                }
            }

            /**
             * 로봇 셀 관리 클래스
             * 로봇 셀 이벤트 및 기능 관리
             */
            class RobotCellManager {
                /**
                 * @param {ProcessMapState} state - 상태 관리 객체
                 */
                constructor(state) {
                    this.state = state;
                }

                /**
                 * 로봇 셀 초기화
                 */
                initRobotCells() {
                    const robotCells = document.querySelectorAll('.robot-cell');

                    robotCells.forEach(cell => {
                        // 셀 클릭 이벤트
                        cell.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const cellText = cell.textContent.trim();

                            // 선택된 셀 강조 표시
                            robotCells.forEach(c => c.style.backgroundColor = 'white');
                            cell.style.backgroundColor = '#d6eaf8';

                            // 셀 정보 툴팁 표시
                            const rect = cell.getBoundingClientRect();
                            this.showCellInfo(cellText, rect.right + 10, rect.top);
                        });

                        // 셀 호버 이벤트
                        cell.addEventListener('mouseover', (e) => {
                            const cellText = cell.textContent.trim();
                            const rect = cell.getBoundingClientRect();

                            let tooltipText = '';
                            if (cellText === '출고') {
                                tooltipText = 'PBS로 데이터 전송';
                            } else {
                                tooltipText = `로봇 스테이션 ${cellText}번`;
                            }

                            this.state.showTooltip(tooltipText, rect.right + 10, rect.top);
                        });

                        cell.addEventListener('mouseout', () => {
                            this.state.hideTooltip();
                        });
                    });
                }

                /**
                 * 셀 정보 표시
                 * @param {string} cellText - 셀 텍스트
                 * @param {number} x - 툴팁 X 좌표
                 * @param {number} y - 툴팁 Y 좌표
                 */
                showCellInfo(cellText, x, y) {
                    let infoText = '';

                    if (cellText === '출고') {
                        infoText = 'PBS 시스템으로 완료 데이터 전송';
                    } else {
                        infoText = `로봇 스테이션 ${cellText}번 - 작업 진행 중`;
                    }

                    this.state.showTooltip(infoText, x, y);
                    setTimeout(() => this.state.hideTooltip(), 2000);
                }
            }

            /**
             * 이벤트 핸들러 클래스
             * 사용자 인터랙션 이벤트 처리
             */
            class EventHandler {
                /**
                 * @param {ProcessMapState} state - 상태 관리 객체
                 * @param {ConnectionManager} connectionManager - 연결선 관리 객체
                 * @param {RobotCellManager} robotCellManager - 로봇 셀 관리 객체
                 */
                constructor(state, connectionManager, robotCellManager) {
                    this.state = state;
                    this.connectionManager = connectionManager;
                    this.robotCellManager = robotCellManager;
                    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                }

                /**
                 * 모든 이벤트 초기화
                 */
                initEvents() {
                    this.initConnectorEvents();
                    this.initControlEvents();
                    this.initResizeEvent();
                    this.robotCellManager.initRobotCells();
                }

                /**
                 * 커넥터 관련 이벤트 초기화
                 */
                initConnectorEvents() {
                    const container = document.getElementById('container');

                    // 이벤트 타입 결정
                    const startEvent = this.isMobile ? 'touchstart' : 'mousedown';
                    const moveEvent = this.isMobile ? 'touchmove' : 'mousemove';
                    const endEvent = this.isMobile ? 'touchend' : 'mouseup';

                    // 커넥터 마우스다운/터치스타트 이벤트 (델리게이션)
                    container.addEventListener(startEvent, e => {
                        const connector = e.target.closest('.connector');
                        if (!connector) return;

                        e.stopPropagation();
                        this.state.dragStart = connector;

                        // 기존 연결 제거
                        const existingConn = this.connectionManager.connectorManager.getConnectionByConnector(this.state.dragStart);
                        if (existingConn) {
                            existingConn[1].line.remove();
                            this.state.connections.delete(existingConn[0]);
                        }

                        // 시작점 좌표 가져오기
                        const rect = connector.getBoundingClientRect();
                        const startX = rect.left + rect.width / 2;
                        const startY = rect.top + rect.height / 2;

                        // 임시 연결선 생성
                        const initialEnd = this.isMobile ? {
                            x: e.touches[0].pageX,
                            y: e.touches[0].pageY
                        } : {
                            x: e.pageX,
                            y: e.pageY
                        };

                        this.state.tempLine = this.connectionManager.createTempLine(this.state.dragStart, initialEnd);

                        connector.classList.add('active');

                        // 툴팁 표시
                        const parentBox = connector.closest('.box');
                        const parentTitle = parentBox.querySelector('h4').textContent;
                        this.state.showTooltip(`${parentTitle}에서 연결 시작`, initialEnd.x + 15, initialEnd.y + 15);
                    });

                    // 마우스무브/터치무브 이벤트
                    document.addEventListener(moveEvent, e => {
                        if (this.state.tempLine) {
                            const pageX = this.isMobile ? e.touches[0].pageX : e.pageX;
                            const pageY = this.isMobile ? e.touches[0].pageY : e.pageY;

                            this.state.tempLine.setOptions({ end: { x: pageX, y: pageY } });

                            // 툴팁 위치 업데이트
                            this.state.tooltip.style.left = `${pageX + 15}px`;
                            this.state.tooltip.style.top = `${pageY + 15}px`;
                        }
                    });

                    // 마우스업/터치엔드 이벤트
                    document.addEventListener(endEvent, e => {
                        if (!this.state.dragStart) return;

                        // 모바일에서는 직접 target을 가져올 수 없으므로 좌표를 기반으로 요소 찾기
                        let targetElement;
                        if (this.isMobile && e.changedTouches && e.changedTouches.length > 0) {
                            const touch = e.changedTouches[0];
                            targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                        } else {
                            targetElement = e.target;
                        }

                        const dragEnd = targetElement ? targetElement.closest('.connector') : null;

                        if (dragEnd && this.state.dragStart !== dragEnd) {
                            // 성공적으로 연결 생성
                            this.connectionManager.createConnection(this.state.dragStart, dragEnd);

                            // 성공 툴팁 표시
                            const startBox = this.state.dragStart.closest('.box').querySelector('h4').textContent;
                            const endBox = dragEnd.closest('.box').querySelector('h4').textContent;
                            this.state.showTooltip(`${startBox}에서 ${endBox}로 연결됨`, e.pageX + 15, e.pageY + 15);
                            setTimeout(() => this.state.hideTooltip(), 1500);
                        } else if (!dragEnd) {
                            // 연결 삭제 또는 실패
                            this.connectionManager.removeConnectionByConnector(this.state.dragStart);

                            // 실패 툴팁 표시
                            this.state.showTooltip('연결 취소됨', e.pageX + 15, e.pageY + 15);
                            setTimeout(() => this.state.hideTooltip(), 1500);
                        }

                        if (this.state.tempLine) {
                            this.state.tempLine.remove();
                            this.state.tempLine = null;
                        }

                        this.state.dragStart.classList.remove('active');
                        this.state.dragStart = null;
                    });

                    // 컨텍스트 메뉴 이벤트 (연결 제거)
                    document.addEventListener('contextmenu', e => {
                        const connector = e.target.closest('.connector');
                        if (connector) {
                            e.preventDefault();
                            this.connectionManager.removeConnectionByConnector(connector);

                            // 삭제 툴팁 표시
                            this.state.showTooltip('연결이 삭제되었습니다', e.pageX + 15, e.pageY + 15);
                            setTimeout(() => this.state.hideTooltip(), 1500);
                        }
                    });

                    // 커넥터에 호버 효과 추가
                    container.addEventListener('mouseover', e => {
                        const connector = e.target.closest('.connector');
                        if (connector && !this.state.dragStart) {
                            const boxTitle = connector.closest('.box').querySelector('h4').textContent;
                            const position = connector.dataset.socket;

                            // 연결 수 확인
                            let connectionCount = 0;
                            this.state.connections.forEach(conn => {
                                if (conn.start === connector || conn.end === connector) {
                                    connectionCount++;
                                }
                            });

                            const tooltip = connectionCount > 0
                                ? `${boxTitle} ${position} 연결 (${connectionCount}개 연결됨)`
                                : `${boxTitle} ${position} 연결점`;

                            const rect = connector.getBoundingClientRect();
                            this.state.showTooltip(tooltip, rect.right + 10, rect.top);
                        }
                    });

                    container.addEventListener('mouseout', e => {
                        const connector = e.target.closest('.connector');
                        if (connector && !this.state.dragStart) {
                            this.state.hideTooltip();
                        }
                    });
                }

                /**
                 * 컨트롤 버튼 이벤트 초기화
                 */
                initControlEvents() {
                    // 컨트롤 버튼 이벤트
                    document.getElementById('resetBtn').addEventListener('click', () => this.state.resetBoxPositions());
                    document.getElementById('resetConnectionsBtn').addEventListener('click', () => this.connectionManager.resetAllConnections());
                }

                /**
                 * 창 크기 변경 이벤트 초기화
                 */
                initResizeEvent() {
                    // 창 크기 변경 이벤트
                    window.addEventListener('resize', () => {
                        // 리사이즈 디바운스 적용
                        if (this.state.resizeTimeout) {
                            clearTimeout(this.state.resizeTimeout);
                        }

                        this.state.resizeTimeout = setTimeout(() => {
                            this.state.connections.forEach(conn => conn.line.position());
                        }, 100);
                    });
                }
            }

            /**
             * 프로세스 맵 애플리케이션 클래스
             * 전체 앱을 관리하는 메인 클래스
             */
            class ProcessMap {
                constructor() {
                    // 초기화 순서 중요
                    this.state = new ProcessMapState();
                    this.colorScheme = new ColorScheme();
                    this.connectorManager = new ConnectorManager(this.state, this.colorScheme);
                    this.connectionManager = new ConnectionManager(this.state, this.connectorManager, this.colorScheme);
                    this.boxDragManager = new BoxDragManager(this.state);
                    this.robotCellManager = new RobotCellManager(this.state);
                    this.eventHandler = new EventHandler(this.state, this.connectionManager, this.robotCellManager);

                    this.initialize();
                }

                /**
                 * 앱 초기화
                 */
                initialize() {
                    window.addEventListener('DOMContentLoaded', () => {
                        this.initTooltip();
                        this.initRobotCellInteractions();
                        this.connectorManager.initConnectors();
                        this.boxDragManager.initBoxDragging();
                        this.eventHandler.initEvents();
                        this.state.saveInitialBoxPositions();

                        // 페이지 로드 후 1초 후에 초기 연결 생성 (DOM이 완전히 렌더링 된 후)
                        setTimeout(() => this.connectionManager.createInitialConnections(), 1000);
                    });
                }

                /**
                 * 로봇 셀 상호작용 초기화
                 */
                initRobotCellInteractions() {
                    // 로봇 셀을 클릭하면 PBS로 데이터가 전송되는 것을 시각적으로 표현
                    document.querySelectorAll('.robot-cell').forEach(cell => {
                        cell.addEventListener('dblclick', () => {
                            // 출고 셀이 아닌 경우에만 처리
                            if (cell.textContent.trim() !== '출고') return;

                            const rrFlrBox = document.querySelector('.box h4').textContent.includes('RR FLR')
                                ? document.querySelector('.box h4').closest('.box')
                                : null;

                            const pbsBox = document.querySelector('.box h4').textContent.includes('PBS')
                                ? document.querySelector('.box h4').closest('.box')
                                : null;

                            if (rrFlrBox && pbsBox) {
                                // 데이터 전송 시각화 - 깜빡임 효과
                                pbsBox.style.transition = 'background-color 0.5s';
                                pbsBox.style.backgroundColor = '#d4efdf';

                                setTimeout(() => {
                                    pbsBox.style.backgroundColor = '';
                                }, 1000);

                                // 툴팁 표시
                                const rect = cell.getBoundingClientRect();
                                this.state.showTooltip('PBS로 데이터 전송 완료', rect.right + 10, rect.top);
                                setTimeout(() => this.state.hideTooltip(), 2000);
                            }
                        });
                    });
                }

                /**
                 * 툴팁 초기화
                 */
                initTooltip() {
                    if (!document.getElementById('tooltip')) {
                        const tooltip = document.createElement('div');
                        tooltip.id = 'tooltip';
                        tooltip.className = 'tooltip';
                        document.body.appendChild(tooltip);
                        this.state.tooltip = tooltip;
                    } else {
                        this.state.tooltip = document.getElementById('tooltip');
                    }
                }
            }

            // 애플리케이션 인스턴스 생성 및 시작
            new ProcessMap();
        })();
    </script>
</body>

</html>