<table>
    <tr>
        <th>
            <h2>중첩 클래스와 중첩 인터페이스</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>중첩 클래스</b>는 다른 클래스 내부에 정의된 클래스입니다.</li>
                <li><b>중첩 인터페이스</b>는 다른 인터페이스 또는 클래스 내부에 정의된 인터페이스입니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>중첩 클래스</b>: 외부 클래스의 멤버로서, 외부 클래스의 필드와 메서드에 접근할 수 있습니다.</li>
                <li><b>중첩 클래스의 접근 제한</b>: 중첩 클래스는 외부 클래스의 접근 제한자에 따라 접근할 수 있습니다.
                    예를 들어, public, private, protected 등이 가능합니다.</li>
                <li><b>중첩 인터페이스</b>: 외부 클래스 또는 다른 인터페이스 안에 정의되며, 인터페이스의 특성을 유지합니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>중첩 클래스는 외부 클래스와 밀접하게 관련된 기능을 그룹화하여 코드의 구조를 개선합니다.</li>
                <li>중첩 클래스는 외부 클래스의 필드와 메서드에 직접 접근할 수 있습니다.</li>
                <li>중첩 인터페이스는 외부 클래스의 기능을 확장하거나 특정 동작을 정의하는 데 사용됩니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>코드의 가독성을 높이고 관련된 기능을 함께 그룹화하기 위해 필요합니다.</li>
                <li>외부 클래스와의 관계를 명확히 하여 유지보수를 용이하게 합니다.</li>
                <li>중첩 인터페이스를 사용하여 특정 컨텍스트에서만 사용되는 인터페이스를 정의할 수 있습니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 외부 클래스
class OuterClass {
    private String outerField = "외부 필드";

    // 중첩 클래스
    class InnerClass {
        void display() {
            System.out.println("중첩 클래스에서: " + outerField);
        }
    }

    // 중첩 인터페이스
    interface InnerInterface {
        void innerMethod();
    }
}

// 중첩 인터페이스 구현
class ImplementInnerInterface implements OuterClass.InnerInterface {
    @Override
    public void innerMethod() {
        System.out.println("중첩 인터페이스 메서드 구현");
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {

        // 중첩 클래스 사용
        OuterClass outer = new OuterClass();
        OuterClass.InnerClass inner = outer.new InnerClass();
        inner.display(); // 출력: 중첩 클래스에서: 외부 필드

        // 중첩 인터페이스 사용
        ImplementInnerInterface impl = new ImplementInnerInterface();
        impl.innerMethod(); // 출력: 중첩 인터페이스 메서드 구현
    }
}
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <tr>
        <th>
            <h2>익명 객체</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>익명 객체</b>는 이름이 없는 객체로, 주로 클래스의 인스턴스를 생성할 때 사용됩니다.</li>
                <li>익명 객체는 즉시 사용되고, 재사용되지 않는 경우에 적합합니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>익명 자식 객체 생성</b>: 상위 클래스를 상속받은 익명 객체를 생성할 수 있습니다.</li>
                <li><b>익명 구현 객체 생성</b>: 인터페이스를 구현한 익명 객체를 생성할 수 있습니다.</li>
                <li><b>익명 객체의 로컬 변수 사용</b>: 익명 객체 내에서 외부의 로컬 변수를 사용할 수 있지만, 이 변수가 final 또는 effectively final이어야 합니다.
                </li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>익명 객체는 코드의 간결성을 높이고, 필요할 때 즉시 생성하여 사용할 수 있습니다.</li>
                <li>이름이 없기 때문에 코드의 가독성을 유지하면서도 간단하게 객체를 생성할 수 있습니다.</li>
                <li>상위 클래스나 인터페이스의 메서드를 재정의하여 즉시 사용할 수 있습니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>일회성 객체를 생성할 때 코드의 양을 줄이기 위해 필요합니다.</li>
                <li>특정 기능을 구현하는 객체가 필요할 때 간단하게 생성하여 사용할 수 있습니다.</li>
                <li>코드의 가독성을 높이고, 불필요한 클래스를 작성하지 않도록 합니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 상위 클래스
class Animal {
    void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {

        // 익명 자식 객체 생성
        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("멍멍 소리를 냅니다."); // 재정의된 메서드
            }
        };
        dog.makeSound(); // 출력: 멍멍 소리를 냅니다.

        // 익명 구현 객체 생성
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("쓰레드가 실행됩니다.");
            }
        };
        new Thread(runnable).start(); // 출력: 쓰레드가 실행됩니다.
        
        // 익명 객체의 로컬 변수 사용
        final String message = "안녕하세요!";
        Runnable greeting = new Runnable() {
            @Override
            public void run() {
                System.out.println(message); // 외부 로컬 변수 사용
            }
        };
        new Thread(greeting).start(); // 출력: 안녕하세요!
    }
}
                </pre>
            </strong>
        </td>
    </tr>
</table>