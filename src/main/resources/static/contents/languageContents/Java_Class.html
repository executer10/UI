<table>
    <tr>
        <th>
            <h2>객체 지향 프로그래밍(Object-Oriented Programming)</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>객체 지향 프로그래밍</b>은 데이터를 객체로 묶어 처리하는 프로그래밍 패러다임입니다.</li>
                <li>객체는 데이터와 해당 데이터를 처리하는 메서드를 포함합니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>객체의 상호작용</b>: 객체는 서로 메시지를 주고받으며 상호작용할 수 있습니다.</li>
                <li><b>객체 간의 관계</b>: 객체는 상속, 포함, 연관 등을 통해 서로 관계를 맺습니다.</li>
                <li><b>객체와 클래스</b>: 객체는 클래스의 인스턴스입니다. 클래스는 객체의 설계도라고 할 수 있습니다.</li>
                <li><b>클래스 선언</b>: 클래스를 정의하여 객체를 생성할 수 있는 구조를 만듭니다.</li>
                <li><b>객체 생성과 클래스 변수</b>: 클래스를 기반으로 객체를 생성하고, 클래스 변수로 공통된 데이터를 유지합니다.</li>
                <li><b>클래스의 구성 멤버</b>: 클래스는 필드(변수), 메서드(함수), 생성자 등으로 구성됩니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>객체 지향 프로그래밍은 코드의 재사용성을 높입니다.</li>
                <li>코드를 모듈화하여 유지보수를 용이하게 합니다.</li>
                <li>실세계의 개념을 모델링하여 이해하기 쉽게 만듭니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>복잡한 시스템을 단순화하여 개발할 수 있습니다.</li>
                <li>유지보수와 확장이 쉬운 코드 구조를 제공합니다.</li>
                <li>협업과 코드 공유가 용이합니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 클래스 선언
class Car {
    // 필드
    String color;
    String model;

    // 생성자
    Car(String color, String model) {
        this.color = color;
        this.model = model;
    }

    // 메서드
    void displayInfo() {
        System.out.println("차 색상: " + color + ", 모델: " + model);
    }
}

// 객체 생성
Car myCar = new Car("빨강", "소나타");
myCar.displayInfo(); // 차 색상: 빨강, 모델: 소나타 출력
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <tr>
        <th>
            <h2>필드(Fields)</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>필드</b>는 클래스 내부에 정의된 변수로, 객체의 속성을 나타냅니다.</li>
                <li>필드는 객체의 상태를 저장하는 데 사용됩니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>필드 선언</b>: 클래스 내에서 필드를 정의하여 데이터 타입과 이름을 지정합니다.</li>
                <li><b>필드 사용</b>: 객체를 통해 필드에 접근하고 값을 읽거나 수정합니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>필드는 객체마다 고유한 값을 가질 수 있습니다.</li>
                <li>필드는 클래스의 구성 요소로, 객체의 상태를 표현합니다.</li>
                <li>접근 제어자를 사용하여 필드의 접근 범위를 설정할 수 있습니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>객체의 속성을 저장하고 관리하기 위해 필요합니다.</li>
                <li>클래스를 통해 관련된 데이터를 구조화할 수 있습니다.</li>
                <li>객체 지향 프로그래밍의 핵심 개념 중 하나로, 코드의 재사용성을 높입니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 클래스 선언
class Person {

    // 필드 선언
    String name; // 이름
    int age; // 나이

    // 생성자
    Person(String name, int age) {
        this.name = name; // 필드 사용
        this.age = age; // 필드 사용
    }

    // 메서드
    void displayInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}

// 객체 생성
Person person1 = new Person("Alice", 30);
person1.displayInfo(); // 이름: Alice, 나이: 30 출력
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <thead>
        <th colspan="3">
            <h2>필드 타입별 초기값</h2>
        </th>
        <tr>
            <th>분류</th>
            <th>타입</th>
            <th>초기값</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="5">기본 타입(정수)</td>
            <td>byte</td>
            <td>0</td>
        </tr>
        <tr>
            <td>char</td>
            <td>'\u0000'</td>
        </tr>
        <tr>
            <td>short</td>
            <td>0</td>
        </tr>
        <tr>
            <td>int</td>
            <td>0</td>
        </tr>
        <tr>
            <td>long</td>
            <td>0L</td>
        </tr>

        <tr>
            <td rowspan="2">기본 타입(실수)</td>
            <td>float</td>
            <td>0.0F</td>
        </tr>
        <tr>
            <td>double</td>
            <td>0.0</td>
        </tr>

        <tr>
            <td>기본 타입(논리)</td>
            <td>boolean</td>
            <td>false</td>
        </tr>

        <tr>
            <td rowspan="3">참조 타입</td>
            <td>class</td>
            <td>null</td>
        </tr>
        <tr>
            <td>interface</td>
            <td>null</td>
        </tr>
        <tr>
            <td>배열</td>
            <td>null</td>
        </tr>
    </tbody>
</table>

<table>
    <tr>
        <th>
            <h2>생성자(Constructor)</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>생성자</b>는 객체가 생성될 때 호출되는 메서드입니다.</li>
                <li>주로 객체의 초기 상태를 설정하는 데 사용됩니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>기본 생성자</b>: 매개변수가 없는 생성자로, 기본값으로 필드를 초기화합니다.</li>
                <li><b>생성자 선언</b>: 생성자의 이름은 클래스와 같아야 하며, 반환 타입이 없습니다.</li>
                <li><b>필드 초기화</b>: 생성자에서 필드를 초기화하여 객체의 상태를 설정합니다.</li>
                <li><b>생성자 오버로딩</b>: 같은 이름의 생성자를 여러 개 정의하여 서로 다른 매개변수를 받을 수 있게 합니다.</li>
                <li><b>다른 생성자 호출(this)</b>: 생성자 내에서 다른 생성자를 호출할 때 사용합니다. `this` 키워드를 사용합니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>생성자는 객체가 생성될 때 자동으로 호출됩니다.</li>
                <li>생성자는 클래스의 인스턴스를 초기화하는 데 필수적입니다.</li>
                <li>생성자 오버로딩을 통해 다양한 방법으로 객체를 생성할 수 있습니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>객체의 초기 상태를 설정하기 위해 필요합니다.</li>
                <li>객체 생성 시 필드를 적절한 값으로 초기화할 수 있습니다.</li>
                <li>코드의 유연성을 높이기 위해 생성자 오버로딩을 사용할 수 있습니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 클래스 선언
class Car {

    // 필드
    String color;    String model;

    // 기본 생성자
    Car() {
        color = "검정"; // 기본 색상
        model = "소형차"; // 기본 모델    
    }

    // 매개변수가 있는 생성자
    Car(String color, String model) {
        this.color = color; // 필드 초기화
        this.model = model; // 필드 초기화    
    }

    // 생성자 오버로딩을 통한 다른 생성자 호출
    Car(String model) {
        this("파랑", model); // 다른 생성자 호출    
    }

    // 메서드
    void displayInfo() {
        System.out.println("차 색상: " + color + ", 모델: " + model);
    }
}
// 객체 생성
Car myCar1 = new Car(); // 기본 생성자 호출myCar1.displayInfo(); // 차 색상: 검정, 모델: 소형차 출력
Car myCar2 = new Car("빨강", "스포츠카"); // 매개변수가 있는 생성자 호출myCar2.displayInfo(); // 차 색상: 빨강, 모델: 스포츠카 출력
Car myCar3 = new Car("SUV"); // 다른 생성자 호출
myCar3.displayInfo(); // 차 색상: 파랑, 모델: SUV 출력
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <tr>
        <th>
            <h2>메소드(Method)</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>메소드</b>는 특정 작업을 수행하는 코드 블록입니다.</li>
                <li>메소드는 객체의 행동을 정의하며, 데이터를 처리합니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>메소드 선언</b>: 메소드를 정의할 때 이름, 반환 타입, 매개변수를 지정합니다.</li>
                <li><b>return</b>: 메소드가 작업을 완료한 후 결과 값을 반환하는 키워드입니다.</li>
                <li><b>메소드 호출</b>: 정의된 메소드를 실행하기 위해 메소드 이름을 사용합니다.</li>
                <li><b>메소드 오버로딩</b>: 동일한 이름의 메소드를 여러 개 정의하여 매개변수의 타입이나 개수에 따라 다르게 동작하게 합니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>메소드는 코드의 재사용성을 높이고, 프로그램을 구조화하는 데 도움을 줍니다.</li>
                <li>메소드의 반환 타입에 따라 결과값을 전달할 수 있습니다.</li>
                <li>오버로딩을 통해 같은 이름의 메소드를 다양한 방식으로 사용할 수 있습니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>복잡한 작업을 단순화하고, 프로그램의 가독성을 높이기 위해 필요합니다.</li>
                <li>코드의 중복을 줄이고, 유지보수를 쉽게 합니다.</li>
                <li>특정 작업을 반복적으로 수행할 수 있게 합니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 클래스 선언
class Calculator {
    // 메소드 선언
    int add(int a, int b) {
        return a + b; // return을 사용하여 결과 반환

    }
    // 메소드 오버로딩
    double add(double a, double b) {
        return a + b; // double 타입의 결과 반환
    }

    // 메소드 호출
    void calculate() {
        int sumInt = add(5, 10); // 정수 더하기
        double sumDouble = add(5.5, 10.5); // 실수 더하기
        System.out.println("정수 합: " + sumInt); // 출력: 정수 합: 15
        System.out.println("실수 합: " + sumDouble); // 출력: 실수 합: 16.0
    }
}

// 객체 생성 및 메소드 호출
Calculator calc = new Calculator();
calc.calculate(); // calculate 메소드 호출
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <tr>
        <th>
            <h2>인스턴스 멤버와 정적 멤버</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>인스턴스 멤버</b>는 클래스의 인스턴스(객체)와 관련된 변수와 메서드입니다.</li>
                <li><b>정적 멤버</b>는 클래스 자체에 속하며, 클래스의 인스턴스와 무관하게 사용할 수 있는 변수와 메서드입니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>인스턴스 멤버와 this</b>: 인스턴스 멤버는 `this` 키워드를 사용하여 현재 객체의 필드와 메서드에 접근할 수 있습니다.</li>
                <li><b>정적 멤버와 static</b>: 정적 멤버는 `static` 키워드를 사용하여 선언하며, 클래스가 메모리에 로드될 때 생성됩니다.</li>
                <li><b>싱글톤</b>: 싱글톤 패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 보장하는 디자인 패턴입니다.</li>
                <li><b>final 필드와 상수</b>: `final` 키워드를 사용하여 선언된 필드는 한 번 초기화된 후 변경할 수 없는 상수를 나타냅니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>인스턴스 멤버는 각 객체마다 독립적인 값을 가질 수 있습니다.</li>
                <li>정적 멤버는 모든 인스턴스에서 공유되며, 클래스 이름으로 접근할 수 있습니다.</li>
                <li>싱글톤 패턴을 사용하면 메모리 사용을 효율적으로 관리할 수 있습니다.</li>
                <li>final 필드는 프로그램 내에서 상수 값을 유지하도록 도와줍니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>인스턴스 멤버는 객체의 상태를 표현하고 관리하기 위해 필요합니다.</li>
                <li>정적 멤버는 공통된 데이터를 클래스 수준에서 관리할 수 있게 합니다.</li>
                <li>싱글톤 패턴은 전역 상태를 관리할 때 유용합니다.</li>
                <li>final 필드는 값이 변하지 않도록 보장하여 코드의 안정성을 높입니다.</li>
            </ol>

            <h3>예제 구문</h3>
            <strong>
                <pre>
// 클래스 선언
class Configuration {
    // 정적 멤버
    static String appName = "MyApp"; // 클래스 레벨에서 공유되는 변수
    
    // 인스턴스 멤버
    final int id; // final 필드
    
    // 생성자
    Configuration(int id) {
        this.id = id; // 인스턴스 멤버 초기화
    }

    // 정적 메서드
    static void displayAppName() {
        System.out.println("앱 이름: " + appName);
    }

    // 인스턴스 메서드
    void displayId() {
        System.out.println("ID: " + id);
    }
}

// 객체 생성
Configuration config1 = new Configuration(1);
config1.displayId(); // ID: 1 출력
Configuration.displayAppName(); // 앱 이름: MyApp 출력

// 정적 멤버에 접근
Configuration.appName = "NewApp"; // 정적 멤버 수정
Configuration.displayAppName(); // 앱 이름: NewApp 출력
                </pre>
            </strong>
        </td>
    </tr>
</table>

<table>
    <tr>
        <th>
            <h2>패키지와 접근 제한자</h2>
        </th>
    </tr>
    <tr>
        <td>
            <h3>제목 정의</h3>
            <ul>
                <li><b>패키지</b>는 관련된 클래스들을 그룹화하여 관리하는 방법입니다.</li>
                <li><b>접근 제한자</b>는 클래스, 필드, 메서드의 접근 수준을 설정하는 키워드입니다.</li>
            </ul>

            <h3>세부 정보 정의</h3>
            <ol>
                <li><b>패키지 선언</b>: 클래스 파일의 최상단에 위치하여 해당 클래스가 어떤 패키지에 속하는지를 정의합니다.</li>
                <li><b>접근 제한자</b>: public, private, protected, default(패키지 전용) 등이 있습니다.</li>
                <li><b>클래스의 접근 제한</b>: 클래스가 다른 클래스에서 어떻게 접근될 수 있는지를 결정합니다.</li>
                <li><b>생성자의 접근 제한</b>: 생성자의 접근 수준을 설정하여 객체 생성의 제어를 할 수 있습니다.</li>
                <li><b>필드와 메소드의 접근 제한</b>: 필드와 메서드의 접근 수준을 설정하여 객체의 상태와 행동을 보호합니다.</li>
                <li><b>Getter와 Setter 메소드</b>: 필드의 값을 읽고 수정하기 위한 메서드로, 일반적으로 private 필드에 접근하기 위해 사용됩니다.</li>
            </ol>

            <h3>특징</h3>
            <ol>
                <li>패키지를 사용하면 코드의 구조를 체계적으로 관리할 수 있습니다.</li>
                <li>접근 제한자를 통해 데이터 은닉을 구현할 수 있습니다.</li>
                <li>Getter와 Setter를 사용하여 객체의 상태를 안전하게 변경할 수 있습니다.</li>
            </ol>

            <h3>사용 이유</h3>
            <ol>
                <li>코드의 가독성을 높이고, 유지보수를 용이하게 하기 위해 필요합니다.</li>
                <li>다른 클래스와의 의존성을 줄이고, 모듈화를 촉진합니다.</li>
                <li>객체의 상태를 보호하고, 불변성을 유지하기 위해 사용합니다.</li>
            </ol>


            <h3>예제 구문</h3>
            <strong>
                <pre>
// 패키지 선언
package com.example.myapp;

// 클래스 선언
public class Person {

    // 필드
    private String name; // 접근 제한자: private
    private int age; // 접근 제한자: private

    // 생성자
    public Person(String name, int age) {
        this.name = name; // this를 사용하여 필드 초기화
        this.age = age; // this를 사용하여 필드 초기화
    }

    // Getter 메서드
    public String getName() {
        return name; // 필드값 반환
    }

    // Setter 메서드
    public void setName(String name) {
        this.name = name; // 필드값 수정
    }

    // 메서드
    public void displayInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}

// 사용 예
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        person.displayInfo(); // 이름: Alice, 나이: 30 출력
        person.setName("Bob"); // 이름 변경
        person.displayInfo(); // 이름: Bob, 나이: 30 출력
    }
}
                </pre>
            </strong>
        </td>
    </tr>
</table>